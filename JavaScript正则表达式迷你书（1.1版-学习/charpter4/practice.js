//  匹配的原理-回溯

// 1. 没有回溯的匹配
var reg = /ab{1,3}c/
// 当字符串为abbbc时,是没有回溯的
// 当字符串为abbc时，是有回溯的

var reg = /".*"/
var str = '"abc"de'

// /".*"/会有一些不必要的回溯过程，因为里面.*影响到它了
// 可以将正则改为

//正则表达式匹配字符串方式:回溯法
// 定义：回溯法也叫试探法：从问题的某个状态出发，搜索从这种状态所能
// 达到的所有状态，当一条路走到尽头时，后退一步或若干步。从另外一种可能的状态
// 触发，继续搜索知道所有状态都试探过，
// 回溯法的本质是深度优先匹配，其中后退到之前某一步的过程，称之为回溯
// 正则匹配失败时,下一步通常就是回溯

// 贪婪量词，它也会发生回溯行为
// 量词是贪婪的所以它会尽可能地多匹配，不匹配，才会后退一步匹配

// 当多个量词存在于一个正则中，并且相互冲突，此时处于靠前位置的量词就会多匹配
// 靠后位置的量词就会少匹配
// 例子：
var str = "12345"
var reg = /(\d{1,3})(\d{1,3})/
console.log(str.match(reg)) //[ '12345', '123', '45', index: 0, input: '12345', groups: undefined ]
// 其中第一个\d{1,3}匹配123，第二个\d{1,3}匹配45

// 惰性量词，在量词后面加个问号，就变成惰性量词了，它表示尽可能少的匹配
// 它也会有回溯现象
var str = "12345"
var reg = /(\d{1,3}?)(\d{1,3})/
console.log(str.match(reg)) //[ '1234', '1', '234', index: 0, input: '12345', groups: undefined ]
// 其中第一个\d{1,3}匹配1，第二个\d{1,3}匹配234

// 分支结构
// 分支结构也是惰性的
var reg = /can|candy/
var str = "candy"
console.log(str.match(reg)) //[ 'can', index: 0, input: 'candy', groups: undefined ]
// 匹配到can就停止继续匹配了

// 分支也是有回溯的,子模式匹配但是整体不匹配，就会转到另外一个分支
var reg = /^(?:can|candy)$/
var str = "candy"
console.log(str.match(reg)) //[ 'candy', index: 0, input: 'candy', groups: undefined ]

// 总结：
// 1. 回溯法就是一个一个去试，直到某一步整体匹配成功火证整体匹配失败
// 2. 贪婪量词的回溯是：从最多到最少
// 3. 惰性量词的回溯是:是从最少到最多
// 4. 分支结构的回溯是:一个条件不行就换另外一个条件
// javaScript的正则引擎是NFA(非确定型有限自动机)，相对于DFA(确定型有限自动机)
// 它的特点是匹配慢编译快。
