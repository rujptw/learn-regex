### js正则匹配
 #### 两种匹配模式
    1. 横向匹配:常与`{}`量词搭配，匹配字符出现的次数。
    2. 纵向匹配:常与`[]`字符组搭配，匹配其中出现的字符，只匹配一次。
    3. 横向匹配例子 `var reg = /ab{2,5}c/g` 表示匹配`abbc,abbbc,abbbbc,abbbbbc`,其中的2和5表示出现字符出现2到5次。
    4. 纵向匹配例子`var reg = /a[123]b/g`表示匹配`a1b,a2b,a3b`,其中1,2,3表示匹配有这些字符的字符串。
#### 量词常见的形式
    1. `{m,}`表示至少出现m次。
    2. `{m}`表示出现m次。
    3. `?`等价于{0,1},表示出现或者不出现。
    4. `+`等价于{1,},表示至少出现一次。
    5. `*`等价于{0,},表现出现任意次，也可能为0。
    6. `{m-n}`等价于从m次到n次,`-`表示范围。
#### 匹配特殊的字符
    1. 使用转义符`\`,比如要单独匹配-,可以在它之前加\或者把特殊字符放到最前面、最后面,形式如下`[a\-b]`],这种就是匹配`a、-、b、`字符，而不是匹配从a-b了。
#### 排除字符组
    1. 使用字符`^`脱字符,例如[^abc],就是匹配除`a,b,c`之外的字符。
#### 字符组的简写形式
    1.`\d`表示[0-9],代表一位数字。
    2. ` \D`表示[^0-9],代表除数字外的任意字符。
    3. `\w`表示[0-9a-zA-Z]_]表示数字，大小写字符和下划线，代表单词字符。
    4. `\W`表示[^0-9a-zA-Z_]，表示非单词字符。
    5. `\s`表示([\t\v\n\r\f])空白符,包括表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。
    6. `\S`表示([^\t\v\n\r\f])非空白符。
    7. `.`表示([^\n\r\u2028\u2029])通配符,表示几乎所有字符,换行符、回车符、行分隔符和段分隔符除外。
#### 贪婪匹配
    1. 特点:尽可能多得匹配,到达自己的极限。
    2. 例子:```
       var reg = /\d{2,5}/g;var str = "123 1234   12345 123456";console.log(str.match(reg));
       匹配结果:['123','1234','12345','12345']
       ```
####  惰性匹配
    1. 特点:尽可能少的匹配满足条件即可，量词后面加个?,贪婪匹配转化为惰性匹配。
    2. 例子:```
            var reg = /\d{2,5}?/g
            var str = "123 1234 12345 123456";
            console.log(str.match(reg));
            匹配结果:[ '12', '12', '34', '12', '34', '12', '34', '56' ]
            ```

>>>量词后面加个?可以实现惰性匹配，例子
```/\a{2,5}?b{3,}?c{4}?d+?e??f*?/```
#### 多选分支
    1. 特点:支持多个子模式任选其一,它是惰性的，只要匹配到一个就不再匹配下去。
    2. 形式(p1|p2|p3),p1,p2,p3是子模式，用|(管道符分割)。
    3. 例子:```
            var reg = /good|nice/g
            var str= 'good idea, nice try';
            console.log(str.match(reg)); //['good','nice']
            <!-- 惰性例子 -->
            var reg = /good|goodbye/g
            var str = "goodbye"
            console.log(str.match(reg)); //['good']
            var reg = /goodbye|good/g
            console.log(str.match(reg)); // [ 'goodbye' ]
            ```
            
>>>匹配字符: 字符组、量词、分支结构的组合使用
>>>使用分支结构时，要注意顺序，可以用小括号()将同一组的包裹起来，代表内部是一个整体，可以查看***第三章***


### 案例分析
```
<!-- 匹配颜色 -->
var reg = /#([0-9a-zA-Z]{6}|[0-9a-zA-Z]{3})/g;
var str = "#ccc #Ffff,#0Fcccc";
    console.log(str.match(reg));//[ '#ccc', '#Fff', '#0Fcccc' ]
```

```
<!-- 匹配时间 -->
<!-- ^:表示匹配字串开头 -->
<!-- ￥:表示匹配字符串结尾 -->
var reg = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
console.log(reg.test("23:59"));//true
console.log(reg.test("02:07"));//true
<!-- 省略时，分前的0 -->
var reg = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;
console.log(reg.test("23:59"));//true
console.log(reg.test("02:07"));//true
console.log(reg.test("7:9"));//true
```

```
<!-- 匹配日期 -->
var reg = /^[0-9]{4}-([0][1-9]|[1][0-2])-([0][1-9]|[12][0-9]|3[01])$/g;
console.log(reg.test("2017-06-12"));//true
```
```
<!-- 匹配文件夹 -->

var reg = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
console.log(reg.test("F:\\study\\javascript\\regex\\regular expression.pdf"));//true
console.log(reg.test("F:\\study\\javascript\\regex\\"));//true
console.log(reg.test("F:\\study\\javascript"));//true
console.log(reg.test("F:\\"));//true

```

```
<!-- 匹配id -->
<!-- 因为.是通配符本身就匹配""，并且量词*是贪婪的，所以会继续匹配匹配到最后一个双引号，所有就有了class="main" -->
var reg = /id=".*"/

var str = '<div id="container" class="main"></div>'
console.log(str.match(reg)[0]);// id="container" class="main"

<!-- 可以使用惰性匹配,但是这个还要个问题就是效率比较低 -->
var reg = /id=".*?"/
console.log(str.match(reg)[0]); //id="container"
<!-- 可以这样优化,这个涉及到回溯，可以查看***第四章*** -->
var reg =/id="[^"]*"/
console.log(str.match(reg)[0]); //id="container"
```

### 总结:
    1. 字符组的形式为[123],代表可以匹配其中的任意一个，可以用连字符a-z,省略书写
    2. 量词的形式为{3,4},代表字符出现的次数。
    3. 量词不加上?的正则，都是贪婪匹配，特点为尽可能多得匹配。
    4. 量词有?修饰的正则，是惰性匹配，特点为能够满足最低要求即可。
    5. ^代表匹配最开始的字符，而$表示匹配最后的字符。
    6. 匹配特殊字符时，有时需要加上转义字符\，比如字符组中的-。

